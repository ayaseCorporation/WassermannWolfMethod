(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["AplanaticSinglet`AsphericalFormulaFitting`",{"AplanaticSinglet`RayTrace2D`"}];


(* ::Input::Initialization:: *)
AsphericalFormulaFittingVersion="AsphericalFormulaFitting 0.1A by Takatoshi Yamada, Ayase corp.";


(* ::Input::Initialization:: *)
AsphericalFormulaFittingDescrciption="AsphericalFormulaFitting package for converting a lens shape expressed by interpolation function into a function in aspherical formula.";


(* ::Input::Initialization:: *)
AsphericalFormulaFittingUsage="res=fitAsphericalExpression[ff,10]
Plot[{ff[y],fittedAsphericalFunction[res,removeOffset\[Rule]False][y]},Evaluate[Flatten[{y,domain2D[ff]}]]]
Plot[ff[y]-fittedAsphericalFunction[res,removeOffset\[Rule]False][y],Evaluate[Flatten[{y,domain2D[ff]}]]]
residualEvaluationValues[ff,res,evaluationWavelength\[Rule]0.000532]";


(* ::Input::Initialization:: *)
fitAsphericalExpression::usage="fitAsphericalExpression[f_InterpolatingFunction,heighestOrder_?IntegerQ] returns list of fitting result rules. Other argument styles,fitAsphericalExpression[f_InterpolatingFunction,paraxialCurvature_?NumericQ,heighestOrder_?IntegerQ], fitAsphericalExpression[f_InterpolatingFunction,paraxialCurvature_?NumericQ,conic_?NumericQ,heighestOrder_?IntegerQ] or fitAsphericalExpression[shape:{{_?NumericQ,_?NumericQ}..},paraxialCurvature_?NumericQ,conicConstant_?NumericQ,heighestOrder_?IntegerQ] etc...";


(* ::Input::Initialization:: *)
constantOffset::usage="constantOffset is a result tag of fitAsphericalExpression that represents constant offset along optical axis.";


(* ::Input::Initialization:: *)
curvature::usage="curvature is a result tag of fitAsphericalExpression that represents paraxial curvature.";


(* ::Input::Initialization:: *)
conicConstant::usage="conicConstant is a result tag of fitAsphericalExpression that represents conic constant.";


(* ::Input::Initialization:: *)
powerSeriesCoefficients::usage="powerSeriesCoefficients is a result tag of fitAsphericalExpression that represents power series coefficients. powerSeriesCoefficients[n] specifies coefficient value of n-th power.";


(* ::Input::Initialization:: *)
normalizationHeight::usage="normalizationHeight is a result tag of fitAsphericalExpression that represents normalized height for power series. When power series order is higher than 14-th, the variable 'y' should be normalized for avoiding cancellation of significant digits.";


(* ::Input::Initialization:: *)
fittedAsphericalFunction::usage="fittedAsphericalFunction[fittingResults:{__Rule}] returns a pure function for fitted aspherical formula.f ittedAsphericalFunction[result:{__Rule}, y_Symbol] returns the function with argument 'y'.";


(* ::Input::Initialization:: *)
removeOffset::usage="removeOffset is an option of fittedAsphericalFunction. If removeOffset->True, a function returned from fittedAsphericalFunction passes {0,0}.";


(* ::Input::Initialization:: *)
fittingAccuracyEvaluationValues::usage="fittingAccuracyEvaluationValues[f_InterpolatingFunction,result:{__Rule},opt___] returns fitting evaluation values, Peak-Valley and RMS of residuals.";


(* ::Input::Initialization:: *)
evaluationWavelength::usage="evaluationWavelength is an option of fittingAccuracyEvaluationValues that specifies a unit. If not specified, Identity will be used.";


(* ::Input::Initialization:: *)
fittingErrorPV::usage="fittingErrorPV is a result tag of fitAsphericalExpression that represents Peak-Valley residual fitting error.";


(* ::Input::Initialization:: *)
fittingErrorRMS::usage="fittingErrorRMS is a result tag of fitAsphericalExpression that represents RMS fitting error.";


(* ::Input::Initialization:: *)
domainDimension::usage="domainDimension[f_InterpolatingFunction] returns function dimensions.";


(* ::Input::Initialization:: *)
maxHeight::usage="maxHeight[f_InterpolationFunctuon] returns maximum height of its domain.";


(* ::Input::Initialization:: *)
plotSpecification::usage="plotSpecification[f_InterpolationFunctuon,x_Symbol] returns {x,xs,xe} style list that can be used in Plot. It should be enclosed in Evaluate[].";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
$orderShouldBeNormalized=16;


(* ::Input::Initialization:: *)
$minimumPowerSeriesOrder=4;
$maximumPowerSeriesOrder=20;


(* ::Input::Initialization:: *)
findParaxialCurvature[f_InterpolatingFunction]:=curvatureFunction[f][0.0]


(* ::Input::Initialization:: *)
curvatureFunction[f_,y_]:=D[f,{y,2}]/(1+D[f,y]^2)^(3/2)
curvatureFunction[f_InterpolatingFunction]:=(f''[#]/(1+f'[#]^2)^(3/2))&
curvatureFunction[f_Function]:=(f''[#]/(1+f'[#]^2)^(3/2))&


(* ::Input::Initialization:: *)
maxHeight[f_InterpolatingFunction]:=Max[Flatten[{domain2D[f],maxHeight[sourcePoints2D[f]]}]]


(* ::Input::Initialization:: *)
maxHeight[l:{{_,_}...}]:=Max[Abs[l[[1,1]]],Abs[l[[-1,1]]]](* assuming argment l comes from InterpolationFunction*)


(* ::Input::Initialization:: *)
sourcePoints2D[f_InterpolatingFunction]:=Transpose[{sourceHeightList[f],f[[4,-1]]}]


(* ::Input::Initialization:: *)
sourceHeightList[f_InterpolatingFunction]:=First[f[[3]]]


(* ::Input::Initialization:: *)
domainDimension[f_InterpolatingFunction]:=Dimensions[f["Domain"]]


(* ::Input::Initialization:: *)
domain2D[f_InterpolatingFunction]:=First[f["Domain"]]


(* ::Input::Initialization:: *)
plotSpecification[f_InterpolatingFunction,x_Symbol]:=Flatten[{x,domain2D[f]}]


(* ::Input::Initialization:: *)
quadCurvatureSeriesUpto6[c_,k_,y_]=Simplify[Normal[Series[curvatureFunction[(c*y^2)/(1+Sqrt[1-c^2*(1+k)*y^2]),y],{y,0,6}]]];


(* ::Input::Initialization:: *)
quadSeriesUpto8[c_,k_,y_]=Simplify[Normal[Series[(c*y^2)/(1+Sqrt[1-c^2*(1+k)*y^2]),{y,0,8}]]];


(* ::Input::Initialization:: *)
sphForm[c_,y_]:=(c*y^2)/(1+Sqrt[1-c^2*y^2])


(* ::Input::Initialization:: *)
quadForm[c_,k_,y_]:=(c*y^2)/(1+Sqrt[1-c^2*(1+k)*y^2])


(* ::Input::Initialization:: *)
insideSqrt[c_,k_,maxH_]:=1-c^2*(1+k)*maxH^2


(* ::Input::Initialization:: *)
realQ[c_,k_,maxH_]:=(insideSqrt[c,k,maxH]>=0.0)


(* ::Input::Initialization:: *)
$edgeMargin=1.+10^-14;


(* ::Input::Initialization:: *)
edgeConic[c_,maxH_]:=1.0/(c*maxH*$edgeMargin)^2-1.0


(* ::Input::Initialization:: *)
removePowerSeries[curvConRemoved:{{_?NumericQ,_?NumericQ}..},coefs:{__Rule}]:=Module[{f},
f=fittedPowerFunction[coefs];
Map[{#[[1]],#[[2]]-f[#[[1]]]}&,curvConRemoved]
]


(* ::Input::Initialization:: *)
removeParaxialCurvature[coords:{{_?NumericQ,_?NumericQ}..},paraxialCurvature_?NumericQ]:=Map[{#[[1]],#[[2]]-sphForm[paraxialCurvature,#[[1]]]}&,coords]


(* ::Input::Initialization:: *)
removeParaxialCurvatureAndConic[coords:{{_?NumericQ,_?NumericQ}..},paraxialCurvature_?NumericQ,k_?NumericQ]:=Map[{#[[1]],#[[2]]-quadForm[paraxialCurvature,k,#[[1]]]}&,coords]


(* ::Input::Initialization:: *)
removeOffset[coords:{{_?NumericQ,_?NumericQ}..},offset_?NumericQ]:=
Map[{#[[1]],#[[2]]-offset}&,coords]


(* ::Input::Initialization:: *)
findPowerSeries[curvConRemoved:{{_?NumericQ,_?NumericQ}..},highestOrder_?IntegerQ]:=Module[{mx,nrm,result},
If[highestOrder>$orderShouldBeNormalized,
mx=maxHeight[curvConRemoved];
nrm=Map[{#[[1]]/mx,#[[2]]}&,curvConRemoved],
mx=1.0;nrm=curvConRemoved];
Flatten[{normalizationHeight->mx,findPowerSeriesInternal[nrm,highestOrder]}]
]


(* ::Input::Initialization:: *)
findPowerSeriesInternal[curvConRemoved:{{_?NumericQ,_?NumericQ}..},highestOrder_?IntegerQ]:=Module[{a,result},
result=FindFit[curvConRemoved,Sum[a[i]y^i,{i,4,highestOrder,2}],Join[{a[0]},Table[a[i],{i,4,highestOrder,2}]],y];
Join[Table[powerSeriesCoefficients[i]->a[i],{i,4,highestOrder,2}]]/.result
]


(* ::Input::Initialization:: *)
kCandidate[c_,mh_,mz_]=(2.0/c-mh^2/mz)/mz-1;
findConic[coords:{{_?NumericQ,_?NumericQ}..},paraxialCurvature_?NumericQ]:=Module[{k,maxH,maxZ,kcand,crem,offset},
{maxH,maxZ}=If[coords[[-1,1]]>0,coords[[-1]],coords[[1]]];
kcand=kCandidate[paraxialCurvature,maxH,maxZ];
k/.FindFit[coords,{quadForm[paraxialCurvature,k,y]+offset,k<edgeConic[paraxialCurvature,maxH]},{{k,kcand},{offset,0.0}},y]
]
(*findConic[coords:{{_?NumericQ,_?NumericQ}..},paraxialCurvature_?NumericQ]:=Module[{maxH,crem,f,k,y,kval,offset},
maxH=maxHeight[coords];
If[!realQ[paraxialCurvature,0,maxH],Return[edgeConic[paraxialCurvature,maxH]]];
crem=removeParaxialCurvature[coords,paraxialCurvature];
kval=k/.FindFit[crem,Evaluate[quadSeriesUpto8[paraxialCurvature,k,y]+offset],{k,offset},y];
Print[kval," ",maxH,realQ[paraxialCurvature,kval,maxH]];
If[realQ[paraxialCurvature,kval,maxH],kval,edgeConic[paraxialCurvature,maxH]]
]*)


(* ::Input::Initialization:: *)
(*the function needs delivative to calculate local curvature *)
findCurvatureAndConic[f_InterpolatingFunction]:=Module[{hlis,crvlis,y,c,k,result},
hlis=sourceHeightList[f];
crvlis=Transpose[{hlis,Map[curvatureFunction[f],hlis]}];
result=FindFit[crvlis,quadCurvatureSeriesUpto6[c,k,y],{c,k},y];
If[realQ[c/.result,k/.result,maxHeight[f]],{curvature->c,conicConstant->k}/.result,{curvature->c,conicConstant->k}/.k->edgeConic[c,maxHeight[f]]/.result]
]


(* ::Input::Initialization:: *)
findOffset[f_InterpolatingFunction]:=f[0.0]
findOffset[coords:{{_?NumericQ,_?NumericQ}..}]:=Module[{hmin},
hmin=Min[Map[Abs[First[#]]&,coords]];
FirstCase[coords,{hmin,v_}->v]
]


(* ::Input::Initialization:: *)
fitAsphericalExpression::tohhighord="`1` may be too high to find power series fitting.";
fitAsphericalExpression::needsfunc="At least curvature value is needed to fit for point list. InterpolationFunction should be provided.";
fitAsphericalExpression::note="The aspherical formula is not suitable for the input shape. Please try other initial parameters or methods.";


(* ::Input::Initialization:: *)
fitAsphericalExpression[f_InterpolatingFunction,highestOrder_?IntegerQ]:=Module[{ccrule},
Check[ccrule=findCurvatureAndConic[f],Message[fitAsphericalExpression::note]];
fitAsphericalExpression[sourcePoints2D[f],curvature/.ccrule,conicConstant/.ccrule,highestOrder]
]


(* ::Input::Initialization:: *)
fitAsphericalExpression[f_InterpolatingFunction,paraxialCurvature_?NumericQ,highestOrder_?IntegerQ]:=fitAsphericalExpression[sourcePoints2D[f],paraxialCurvature,highestOrder]


(* ::Input::Initialization:: *)
fitAsphericalExpression[f_InterpolatingFunction,paraxialCurvature_?NumericQ,conic_?NumericQ,highestOrder_?IntegerQ]:=fitAsphericalExpression[sourcePoints2D[f],paraxialCurvature,conic,highestOrder]


(* ::Input::Initialization:: *)
fitAsphericalExpression[coords:{{_?NumericQ,_?NumericQ}..},highestOrder_?IntegerQ]:=(Message[fitAsphericalExpression::needsfunc];$Failed)


(* ::Input::Initialization:: *)
fitAsphericalExpression[coords:{{_?NumericQ,_?NumericQ}..},paraxialCurvature_?NumericQ,highestOrder_?IntegerQ]:=Module[{k},
Check[k=findConic[coords,paraxialCurvature],Message[fitAsphericalExpression::note]];
fitAsphericalExpression[coords,paraxialCurvature,k,highestOrder]
]


(* ::Input::Initialization:: *)
fitAsphericalExpression[coords:{{_?NumericQ,_?NumericQ}..},paraxialCurvature_?NumericQ,conic_?NumericQ,highestOrder_?IntegerQ]:=Module[{offs,rmoffset,rmcc,pws},
If[highestOrder>$maximumPowerSeriesOrder,Message[fitAsphericalExpression::tohhighord,highestOrder];Return[$Failed]];
offs=findOffset[coords];
rmoffset=removeOffset[coords,offs];
If[highestOrder<4,Return[{curvature->paraxialCurvature,conicConstant->conic}]];
rmcc=removeParaxialCurvatureAndConic[rmoffset,paraxialCurvature,conic];
pws=findPowerSeries[rmcc,highestOrder];
Flatten[{constantOffset->offs,curvature->paraxialCurvature,conicConstant->conic,pws}]
]


(* ::Input::Initialization:: *)
Options[fittedAsphericalFunction]={removeOffset->True};
fittedAsphericalFunction[fittingResults:{__Rule},arg_Symbol,opt___]:=fittedAsphericalFunction[fittingResults,opt][arg]
fittedAsphericalFunction[fittingResults:{__Rule},opt___]:=With[{invMaxH=1.0/normalizationHeight/.fittingResults,offset=If[removeOffset/.{opt}/.Options[fittedAsphericalFunction],0.0,constantOffset/.fittingResults]},Function[{y},Evaluate[quadForm[curvature/.fittingResults,conicConstant/.fittingResults,y]+fittedPowerFunction[fittingResults][y*invMaxH]]+offset]
]


(* ::Input::Initialization:: *)
fittedPowerFunction[fittingResults:{__Rule}]:=Function[{y},Evaluate[With[{m=maxOrderInResults[fittingResults]},Sum[(powerSeriesCoefficients[i]/.fittingResults)y^i,{i,4,m,2}]]]
]


(* ::Input::Initialization:: *)
maxOrderInResults[fittingResults:{__Rule}]:=Max[Cases[Map[First,fittingResults],powerSeriesCoefficients[_]]/.powerSeriesCoefficients[i_]->i]


(* ::Input::Initialization:: *)
fittingAccuracyEvaluationValues::notrules="Argument rule list is not produced by fitting functions.";
Options[fittingAccuracyEvaluationValues]={evaluationWavelength->None};
fittingAccuracyEvaluationValues[f_InterpolatingFunction,fittingResults:{__Rule},opt___]:=fittingAccuracyEvaluationValues[sourcePoints2D[f],fittingResults,opt]
fittingAccuracyEvaluationValues[shape:{{_?NumericQ,_?NumericQ}..},fittingResults:{__Rule},opt___]:=Module[{lambda,f,resd},
lambda=evaluationWavelength/.{opt}/.Options[residualEvaluationValues];
If[!NumericQ[lambda],lambda=1.0];
f=fittedAsphericalFunction[fittingResults,removeOffset->False];
resd=Map[#[[2]]-f[#[[1]]]&,shape];
{fittingErrorPV->-Apply[Subtract,MinMax[resd]]/lambda,fittingErrorRMS->RootMeanSquare[resd]/lambda}
]


(* ::Input::Initialization:: *)
End[];
EndPackage[];



