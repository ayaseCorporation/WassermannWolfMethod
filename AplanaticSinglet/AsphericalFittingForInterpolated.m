(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["AplanaticSinglet`AsphericalFittingForInterpolated`",{"AplanaticSinglet`RayTrace2D`"}];


(* ::Input::Initialization:: *)
AsphericalFittingForInterpolatedVersion="AsphericalFittingForInterpolated 0.1A by Takatoshi Yamada, Ayase corp.";


(* ::Input::Initialization:: *)
AsphericalFittingForInterpolatedDescrciption="AsphericalFittingForInterpolatedVersion package for converting a lens shape expressed by interpolation function into a function in aspherical formula.";


(* ::Input::Initialization:: *)
AsphericalFittingForInterpolatedVersion="version0.1A";


(* ::Input::Initialization:: *)
AsphericalFittingForInterpolatedUsage="type '?fitAsphericalFomura' and '?elliminateConstantOffset' to show usage texts.";


(* ::Input::Initialization:: *)
fitAsphericalFormula::usage="fitAsphericalFormula[if_InterpolatingFunction,explicitCurvature_?NumericQ,heighestOrder_,opt___] returns coefficients of aspherical formura from InterpolationFunction. This call needs to specify paraxial curvature of the function.
fitAsphericalFormula[\"output\"] returns tag symbols of fitted coefficients.
fitAsphericalFormula[fittedResult:{_Rule...}][y_] returns a Mathematica function for variable 'y' to give a result of fitted coefficients.
fitAsphericalFormula[\"formula\"][y_] returns aspherical formula for variable y.";


(* ::Input::Initialization:: *)
forceParabolic::usage="forceParabolic is an option of fitAsphericalFormula. Fitting will be tried using conic constant = -1.";


(* ::Input::Initialization:: *)
conicSuggestion::usage="conicSuggestion is an option of fitAsphericalFormula. It specifies initial value for conic constant. The default value is 0.0.";


(* ::Input::Initialization:: *)
outputMathematicaFunction::usage="outputMathematicaFunction is an option of fitAsphericalFormula. If it is specified True, fitAsphericalFormula returns Mathematica Function.";


(* ::Input::Initialization:: *)
elliminateConstantOffset::usage="fitAsphericalFomura[elliminateConstantOffset[fittedResult]][y_] returns a Mathematica function without constant offset value.";


(* ::Input::Initialization:: *)
asphericalFormulaFitting::usage="asphericalFormulaFitting is a tag for surface attribute.";


(* ::Input::Initialization:: *)
{constantOffset,curvature,conicConstant,powerSeriesCoefficients,normalizationRadius};


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
minimize2ndCoefficient[pnts:{{_,_}...},func_,{coef_Symbol->ival_?NumberQ},v_Symbol]:=Module[{x,fv},
FindMinimum[(fv=(Fit[Map[{#[[1]],#[[2]]-(func/.v->#[[1]])}&,pnts],{x^2},x]/.x->1)^2),{coef,ival}]
]


(* ::Input::Initialization:: *)
Clear[fitAsphericalFormula];
fitAsphericalFormula["formula"][y_]=(curvature*y^2)/(1+Sqrt[1-curvature^2*(1+conicConstant)*y^2])+Sum[powerSeriesCoefficients[i]y^i,{i,4,10,2}];
fitAsphericalFormula["output"]={constantOffset,curvature,conicConstant,powerSeriesCoefficients};
fitAsphericalFormula::cantfindk="can not find proper conic constant value. Try to specify suggestions.";


(* ::Input::Initialization:: *)
Options[fitAsphericalFormula]={forceParabolic->False,conicSuggestion->0,outputMathematicaFunction->False};
fitAsphericalFormula[fittedResult:{_Rule...}][y_]:=Module[{orders,quad,pw},
quad=(curvature*y^2)/(1+Sqrt[1-curvature^2*(1+conicConstant)*y^2])/.fittedResult;
orders=Cases[Map[First,fittedResult],powerSeriesCoefficients[i_]->i];
pw=Map[(powerSeriesCoefficients[#]y^#)&,orders]/.fittedResult;
quad+Apply[Plus,pw]+(constantOffset/.fittedResult)
]/;(! MemberQ[Map[First,fittedResult],normalizationRadius])
fitAsphericalFormula[fittedResult:{_Rule...}][y_]:=Module[{orders,quad,pw,rad},
rad=normalizationRadius/.fittedResult;
quad=(curvature*y^2)/(1+Sqrt[1-curvature^2*(1+conicConstant)*y^2])/.fittedResult;
orders=Cases[Map[First,fittedResult],powerSeriesCoefficients[i_]->i];
pw=Map[(powerSeriesCoefficients[#](y/rad)^#)&,orders]/.fittedResult;
quad+Apply[Plus,pw]+(constantOffset/.fittedResult)
]/;MemberQ[Map[First,fittedResult],normalizationRadius]

fitAsphericalFormula[if_InterpolatingFunction,explicitCurvature_?NumericQ,heighestOrder_?IntegerQ,opt___Rule]:=Module[{orgv,quad,quadk,y,surfpnts,k,kini,ksol,fk,ppnt,spow,kval,csug,para,normr,ret},
csug=conicSuggestion/.{opt}/.Options[fitAsphericalFormula];
para=forceParabolic/.{opt}/.Options[fitAsphericalFormula];
quad=(explicitCurvature*y^2)/(1+Sqrt[1-explicitCurvature^2*(1+k)*y^2]);
orgv=if[0];
surfpnts=Map[{#,if[#]-orgv}&,interpolationSectionPoints[if]];
ksol=If[para,{{k->-1}},
kini=Check[FindFit[surfpnts,quad,{{k,csug}},y],Message[fitAsphericalFormula::cantfindk];Return[$Failed]];
minimize2ndCoefficient[surfpnts,quad,kini,y]];
quadk=quad/.ksol[[-1]];
kval=k/.ksol[[-1]];
ppnt=Map[{#[[1]],#[[2]]-quadk/.y->#[[1]]}&,surfpnts];
spow=If[heighestOrder<4,{},
If[heighestOrder<=16,
CoefficientList[Fit[ppnt,Table[y^n,{n,4,heighestOrder,2}],y],y],normr=Max[Abs[interpolationDomain[if]]];CoefficientList[Fit[normalizeRadius[ppnt,normr],Table[y^n,{n,4,heighestOrder,2}],y],y]]];
ret=Flatten[{constantOffset->orgv,curvature->explicitCurvature,conicConstant->kval,Select[MapIndexed[powerSeriesCoefficients[#2[[1]]-1]->#1&,spow],#[[-1]]=!=0&]}];
If[NumericQ[normr],AppendTo[ret,normalizationRadius->normr],ret];
If[(outputMathematicaFunction/.{opt}/.Options[fitAsphericalFormula]),fitAsphericalFormula[ret][#]&,ret]
]


(* ::Input::Initialization:: *)
normalizeRadius[pnts:{{_,_}...},rad_]:=Map[{#[[1]]/rad,#[[2]]}&,pnts]


(* ::Input::Initialization:: *)
elliminateConstantOffset[result:{_Rule...}]:=Prepend[result,constantOffset->0]


(* ::Input::Initialization:: *)
End[];
EndPackage[];



