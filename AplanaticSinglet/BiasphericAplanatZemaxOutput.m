(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["AplanaticSinglet`BiasphericAplanatZemaxOutput`",{"AplanaticSinglet`RayTrace2D`","AplanaticSinglet`BiasphericAplanatSolver`","AplanaticSinglet`AsphericalFormulaFitting`","AplanaticSinglet`SingletParaxialConstraints`"}];


(* ::Input::Initialization:: *)
BiasphericAplanatZemaxOutputVersion="BiasphericAplanatZemaxOutput 0.1A20201221 by Takatoshi Yamada, Ayase corp.";


(* ::Input::Initialization:: *)
BiasphericAplanatZemaxOutputDescription="BiasphericAplanatZemaxOutput package can produce Zemax compatible lens description string.";


(* ::Input::Initialization:: *)
BiasphericAplanatZemaxOutputVersion="BiasphericAplanatZemaxOutput ver.0.1";
BiasphericAplanatZemaxOutputDescription="BiasphericAplanatZemaxOutput package is used to convert BiasphericAplanatSolver result to Zemax ascii file format .zmx.";
BiasphericAplanatZemaxOutputUsage="";


(* ::Input::Initialization:: *)
zmxStringFromSolvedBiasphericAplanat::usage="zmxStringFromSolvedBiasphericAplanat[op_?opticsQ,solverResult:{__Rule}] returns a string in Zemax file i.e., .zmx format. The first argument is an optics object from RayTrace2D package and the second argument is a list of the solver result. NOTE: A file named .zmx from the output string can not be read into Zemax. It probably may be required in a string format with UTF-16LE for character encoding  and CR-LF for newline (EOL). Please copy and paste to a suitable text editor  and save with an adequate file format because Mathematica has no UTF-16 encoding converter.";


(* ::Input::Initialization:: *)
attachAsphericalFormulaToSurface::usage="attachAsphericalFormulaToSurface[op_?opticsQ,surfaceNumber_?IntegerQ,fitResult:{__Rule}] set coefficients of aspherical formula of a surface to optics object.  This function should be called before creating a Zemax string by zmxStringFromSolvedBiasphericAplanat.";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
zemaxHeader={"VERS 170426 19 100807
",
"MODE SEQ
",
"NAME 
",
"PFIL 0 0 0
",
"LANG 1
",
"UNIT MM X W X CM MR CPMM
"};


(* ::Input::Initialization:: *)
objectSurface={"SURF 0
",
"  TYPE STANDARD
",
"  FIMP 
",
"
",
"  CURV 0.0 0 0 0 0 
",
"  HIDE 0 0 0 0 0 0 0 0 0 0
",
"  MIRR 2 0
",
"  SLAB 4
",
"  DISZ INFINITY
",
"  DIAM 0 0 0 0 1 
",
"  MEMA 0 0 0 0 1 
",
"  POPS 0 0 0 0 0 0 0 0 1 1 1 1 0 0 0 0
"};
inFiniteObjectSruface[]:=objectSurface


(* ::Input::Initialization:: *)
Clear[numberLineWithKeyWord];
Clear[noNewLine];
Clear[noIndent];
Clear[noIndentNorNewLine];
orderedKeyWord[keyWord_String,order_?IntegerQ]:=keyWordWithString[keyWord,ToString[order]]
orderedKeyWord[keyWord_String,order_?IntegerQ,noNewLine]:=keyWordWithString[keyWord,ToString[order],noNewLine]
orderedKeyWord[keyWord_String,order_?IntegerQ,noIndent]:=keyWordWithString[keyWord,ToString[order],noIndent]
orderedKeyWord[keyWord_String,order_?IntegerQ,noIndentNorNewLine]:=keyWordWithString[keyWord,ToString[order],noIndentNorNewLine]


(* ::Input::Initialization:: *)
keyWordWithString[keyWord_String,str_String]:=keyWordWithString[keyWord,str,noNewLine]<>"
"
keyWordWithString[keyWord_String,str_String,noIndent]:=keyWordWithString[keyWord,str,noIndentNorNewLine]<>"
"
keyWordWithString[keyWord_String,str_String,noNewLine]:="  "<>keyWordWithString[keyWord,str,noIndentNorNewLine]
keyWordWithString[keyWord_String,str_String,noIndentNorNewLine]:=keyWord<>" "<>str


(* ::Input::Initialization:: *)
numberLineWithKeyWord[keyWord_?StringQ,num_?NumberQ]:=keyWordWithString[keyWord,ToString[NumberForm[num,12,ScientificNotationThreshold->{-3,3},NumberFormat->(If[ToString[#3]=="",#1,Row[{#1, "E", #3}]] & )]]]
numberLineWithKeyWord[keyWord_?StringQ,num_?NumberQ,noIndent]:=keyWordWithString[keyWord,ToString[NumberForm[num,12,ScientificNotationThreshold->{-3,3},NumberFormat->(If[ToString[#3]=="",#1,Row[{#1, "E", #3}]] & )]],noIndent]
numberLineWithKeyWord[keyWord_?StringQ,c_?IntegerQ,num_?NumberQ]:=numberLineWithKeyWord[orderedKeyWord[keyWord,c,noIndentNorNewLine],num]
numberLineWithKeyWord[keyWord_?StringQ,c_?IntegerQ,num_?NumberQ,noIndent]:=numberLineWithKeyWord[orderedKeyWord[keyWord,c,noIndentNorNewLine],num,noIndent]


(* ::Input::Initialization:: *)
zemxkeyWords={wavelength->"WAVM",primaryWavelength->"PWAV",surfaceComment->"COMM",blankOperand->"BLNK",imageHeightType->"FTYP"};


(* ::Input::Initialization:: *)
zemaxEPDLine[epd_?NumericQ]:=numberLineWithKeyWord["ENPD",epd,noIndent]
zemaxWavelengthLine[lambda_?NumericQ]:=numberLineWithKeyWord["WAVM",1,lambda*1000,noIndent]<>orderedKeyWord["PWAV",1,noIndent]
zemaxSurfaceTypeLine[typ_?StringQ]:=keyWordWithString["TYPE",typ]
zemaxSurfaceCurvatureLine[curv_?NumericQ]:=numberLineWithKeyWord["CURV",curv]
zemaxSurfaceConicLine[conic_?NumericQ]:=numberLineWithKeyWord["CONI",conic]
zemaxSurfaceDiameterLine[diam_?NumericQ]:=numberLineWithKeyWord["DIAM",diam]
zemaxSurfaceDistanceLine[dist_?NumericQ]:=numberLineWithKeyWord["DISZ",dist]
zemaxSurfaceGlassLine[glass_?StringQ]:=keyWordWithString["GLAS",glass]
zemaxSurfaceGlassLine["atmosphere"]:=Nothing


(* ::Input::Initialization:: *)
Clear[zemaxSurfaceParameterLine];zemaxSurfaceParameterLine[pnum_?IntegerQ,val_?NumericQ]:=numberLineWithKeyWord["PARM",pnum,val]
zemaxSurfaceParameterLine[pnum_?IntegerQ,_]:=numberLineWithKeyWord["PARM",pnum,0]


(* ::Input::Initialization:: *)
Clear[zemaxSurfaceXDatLine];zemaxSurfaceXDatLine[pnum_?IntegerQ,val_?NumericQ]:=numberLineWithKeyWord["XDAT",pnum,val]
zemaxSurfaceXDatLine[pnum_?IntegerQ,_]:=numberLineWithKeyWord["XDAT",pnum,0]


(* ::Input::Initialization:: *)
parmNumberToOrder[parmnum_?IntegerQ]:=parmnum*2
xdatNumberToOrder[xdatnum_?IntegerQ]:=(xdatnum-4)*2+4
xdatNumberFromOrder[order_?IntegerQ]:=(order+4)/2


(* ::Input::Initialization:: *)
parameterLines[fitResult:{__Rule}]:=Array[zemaxSurfaceParameterLine[#,powerSeriesCoefficients[parmNumberToOrder[#]]/.fitResult]&,8]


(* ::Input::Initialization:: *)
xdatLines[fitResult:{__Rule}]:=Module[{s,n,str},
s=2;
n=xdatNumberFromOrder[Max[Cases[Map[First,fitResult],powerSeriesCoefficients[a_]->a]]];
str={zemaxSurfaceXDatLine[1,n-s]};
AppendTo[str,zemaxSurfaceXDatLine[2,normalizationRadius/.fitResult]];
AppendTo[str,Array[zemaxSurfaceXDatLine[#,powerSeriesCoefficients[xdatNumberToOrder[#]]/.fitResult]&,n-s,s+1]];
str
]


(* ::Input::Initialization:: *)
zemaxSurface[surf_?surfaceQ,medium_?mediumQ,surfaceNumber_?IntegerQ,distanceToNext_?NumericQ]:=zemaxAsphericSurface[surf,medium,surfaceNumber,distanceToNext]/;surfaceShapeType[surf]===parametric
zemaxSurface[surf_?surfaceQ,medium_?mediumQ,surfaceNumber_?IntegerQ,distanceToNext_?NumericQ]:=zemaxPlaneSurface[surf,medium,surfaceNumber,distanceToNext]/;surfaceShapeType[surf]===plane
zemaxSurface[surf_?surfaceQ,medium_?mediumQ,surfaceNumber_?IntegerQ,distanceToNext_?NumericQ]:=zemaxSphericalSurface[surf,medium,surfaceNumber,distanceToNext]/;surfaceShapeType[surf]===spherical
zemaxSurface[surf_?surfaceQ,medium_?mediumQ,surfaceNumber_?IntegerQ,distanceToNext_?NumericQ]:=zemaxQuadraticSurface[surf,medium,surfaceNumber,distanceToNext]/;surfaceShapeType[surf]===quadratic


(* ::Input::Initialization:: *)
Clear[zemaxAsphericSurface];zemaxAsphericSurface[surf_?surfaceQ,medium_?mediumQ,surfaceNumber_?IntegerQ,distanceToNext_?NumericQ]:=Module[{fitResult,coff,curv,k,exasp,strlis,d},
fitResult=surf[asphericalFormulaFitting];
coff=constantOffset/.fitResult;
curv=curvature/.fitResult;
k=conicConstant/.fitResult;
d=Max[Abs[clearAperture[surf]]];
exasp=MemberQ[Map[First,fitResult],normalizationRadius];
strlis={orderedKeyWord["SURF",surfaceNumber,noIndent]};
AppendTo[strlis,zemaxSurfaceTypeLine[If[exasp,"XASPHERE","EVENASPH"]]];
AppendTo[strlis,zemaxSurfaceCurvatureLine[curv]];
AppendTo[strlis,If[exasp,xdatLines[fitResult],parameterLines[fitResult]]];
AppendTo[strlis,zemaxSurfaceConicLine[k]];
AppendTo[strlis,zemaxSurfaceDistanceLine[distanceToNext]];
AppendTo[strlis,zemaxSurfaceGlassLine[medium[mediumName]]];
(*AppendTo[strlis,zemaxSurfaceDiameterLine[d]];*)
strlis
]


(* ::Input::Initialization:: *)
zemaxPlaneSurface[surf_?surfaceQ,medium_?mediumQ,surfaceNumber_?IntegerQ,distanceToNext_?NumericQ]:=Module[{strlis,ca},
strlis={orderedKeyWord["SURF",surfaceNumber,noIndent]};
AppendTo[strlis,zemaxSurfaceTypeLine["STANDARD"]];
AppendTo[strlis,zemaxSurfaceCurvatureLine[0.0]];
AppendTo[strlis,zemaxSurfaceDistanceLine[distanceToNext]];
AppendTo[strlis,zemaxSurfaceGlassLine[medium[mediumName]]];
(*ca=clearAperture[surf];
If[ca=!=dmoainAll,
AppendTo[strlis,zemaxSurfaceDiameterLine[Max[Abs[ca]]]]];*)
strlis
]


(* ::Input::Initialization:: *)
zemaxSphericalSurface[surf_?surfaceQ,medium_?mediumQ,surfaceNumber_?IntegerQ,distanceToNext_?NumericQ]:=Module[{strlis},
strlis={orderedKeyWord["SURF",surfaceNumber,noIndent]};
AppendTo[strlis,zemaxSurfaceTypeLine["STANDARD"]];
AppendTo[strlis,zemaxSurfaceCurvatureLine[curvature[surf[shape]]]];
AppendTo[strlis,zemaxSurfaceDistanceLine[distanceToNext]];
AppendTo[strlis,zemaxSurfaceGlassLine[medium[mediumName]]];
(*AppendTo[strlis,zemaxSurfaceDiameterLine[Max[Abs[clearAperture[surf]]]]];*)
strlis
]
zemaxQuadraticSurface[surf_?SurfaceQ,medium_?mediumQ,surfaceNumber_?IntegerQ,distanceToNext_?NumericQ]:=Module[{strlis},
strlis={orderedKeyWord["SURF",surfaceNumber,noIndent]};
AppendTo[strlis,zemaxSurfaceTypeLine["STANDARD"]];
AppendTo[strlis,zemaxSurfaceCurvatureLine[curvature[surf[shape]]]];
AppendTo[strlis,zemaxSurfaceConicLine[conicConstant[surf[shape]]]];
AppendTo[strlis,zemaxSurfaceDistanceLine[distanceToNext]];
AppendTo[strlis,zemaxSurfaceGlassLine[medium[mediumName]]];
(*AppendTo[strlis,zemaxSurfaceDiameterLine[Max[Abs[clearAperture[surf]]]]];*)
strlis
]


(* ::Input::Initialization:: *)
zmxStringFromSolvedBiasphericAplanat[op_?opticsQ,solverResult:{__Rule}]:=Module[{distl,strlis,parms,surfs,meds},
parms=solverResult;
surfs=op[surfaces];
meds=op[mediums];
distl=distanceList[op];
(*If[distl[[-1]]<0.0,distl=Most[distl]];*)
strlis={zemaxHeader,objectSurface};
AppendTo[strlis,zemaxEPDLine[2*focalLength*numericalAperture/.parms]];
AppendTo[strlis,zemaxWavelengthLine[designWavelength/.parms]];
AppendTo[strlis,objectSurface];
AppendTo[strlis,MapIndexed[zemaxSurface[surfs[[#2[[1]]]],meds[[#2[[1]]+1]],#2[[1]],#1]&,distl]];
StringJoin[Flatten[strlis]]
]


(* ::Input::Initialization:: *)
distanceList[op_?opticsQ]:=Module[{surfs,poss},
surfs=op[surfaces];
poss=Map[surfacePosition,surfs];
Most[Map[Apply[Subtract,#]&,Transpose[{RotateLeft[poss],poss}]]]
]


(* ::Input::Initialization:: *)
attachAsphericalFormulaToSurface[op_?opticsQ,num_?IntegerQ,fitResult:{__Rule}]:=attachAttributeToSurface[op[surfaces][[num]],asphericalFormulaFitting,fitResult];


(* ::Input::Initialization:: *)
End[];
EndPackage[];



