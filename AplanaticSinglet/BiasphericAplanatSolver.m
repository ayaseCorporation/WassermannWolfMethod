(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["AplanaticSinglet`BiasphericAplanatSolver`",{"AplanaticSinglet`SingletParaxialConsistency`","AplanaticSinglet`RayTrace2D`"}];


(* ::Input::Initialization:: *)
BiasphericAplanatSolverVersion::usage="BiasphericAplanatSolver ver.0.2A20200702";
BiasphericAplanatSolverDescription="BiasphericAplanatSolver package fixes biaspheric aplanat (aspheric singlet lens) by numerical integration with given parameters. Conjugate condition (finite or infinite) is determined from the given parameter set. The parameter set can include cover glasses. If parameter set is consistent for paraxial condition, the numerical integration will be performed upto given numrical aperture value. The numerical integration may be interrupted by ";


(* ::Input::Initialization:: *)
BiasphericAplanatSolverUsage="Needs[\"AplanaticSinglet`BiasphericAplanatSolver`\"]
createConstantMedium[bk7, 1.5268]
biasphericAplanatParameterSymbols
parms = {designWavelength -> 0.00064, numericalApertureTarget -> 0.6, 
   lensMediumSymbol -> bk7, lensMediumThickness -> 4, 
   mechanicalImageDistance -> 3.66, coverGlassMediumSymbol -> bk7, 
   coverGlassThickness -> 0.6, mechanicalObjectImageDistance -> 30., 
   lateralMagnification -> -0.25, objectSideCoverGlassMediumSymbol -> bk7, 
   objectSideCoverGlassThickness -> 5};
bp = setupBiasphericAplanatParameters[parms];
result = biasphericAplanatSolve[bp, AccuracyGoal -> 14, MaxStepSize -> 0.01]
setOpticsFor2DRayTraceFinite[op, result]
rs = Map[traceRay[op][#, designWavelength /. result] &, 
   Table[raySet[{0, -mechanicalObjectDistance /. result}, {Sin[h], Cos[h]}], 
    Evaluate[{h, -numericalAperture*lateralMagnification, 
       numericalAperture*lateralMagnification, numericalAperture*lateralMagnification/64} /. 
      result]]];
Show[rayCongruenceGraphics[rs, removeLast -> True, rayCount -> 20], 
 opticsGraphics[op, removeLast -> True], Axes -> True, ImageSize -> Large]
ListLinePlot[
 Map[# - {lensMediumThickness + mechanicalImageDistance /. result, 0} &, 
  Select[Map[lateralAberPositionReversed, rs], #[[-1]] >= 0.0 &]], 
 PlotRange -> Automatic]
ListLinePlot[
 Select[Map[oscValueReversed[#, focalLength /. result] &, 
   rs], #[[-1]] >= 0.0 &]]
ListLinePlot[
 Map[Last, opticalPathDifference[Map[opticalPathLengthForHeight, rs]]], 
 PlotRange -> All]";


(* ::Input::Initialization:: *)
biasphericAplanatParameterSymbols::usage="biasphericAplanatParameterSymbols is a tag for a list of  parameter symbols for the biaspheric aplanat solver.";


(* ::Input::Initialization:: *)
designWavelength::usage="designWavelength is a parameter for the solver specifying the wavelength to fix a refractive indices of materials.";


(* ::Input::Initialization:: *)
lensMediumSymbol::usage="lensMediumSymbol is a parameter for the solver specifying a material of the lens body. To specify a medium, refractive index calculation mechanism in the 'RayTrace2D' package.";


(* ::Input::Initialization:: *)
numericalApertureTarget::usage="numericalApertureTarget is a parameter for the solver specifying the numerical aperture in the IMAGE space. It is only a 'target' and the solver returns smaller numrical aperture depending parameters.";


(* ::Input::Initialization:: *)
mechanicalImageDistance::usage="mechanicalWorkingDistance is a parameter for the solver specifying distance from top of the backsurface to image plane. The value should not be paraxial length but mechanical and including cover glass if present. If cover glass not present, mechanicalImageDistance is equal to working distance. For infinite conjugate, mechanicalImageDistance is equal to back focal distance.";


(* ::Input::Initialization:: *)
mechanicalObjectDistance::usage="mechanicalObjectDistance is a parameter for the solver specifing distance from object plane to top of frontSurface. The value should not be paraxial length but mechanical and including object side cover glass if present. For infinite conjugate, mechanicalObjectDistance is automatically assigned to Infinity.";


(* ::Input::Initialization:: *)
coverGlassMediumSymbol::usage="coverGlassMediumSymbol s a parameter for the solver specifying cover glass material. It is treated same as lensMediumSymbol. The cover glass is always assumed in image side of the lens. Default medium is 'atomosphere'.";


(* ::Input::Initialization:: *)
coverGlassThickness::usage="coverGlassThickness is a parameter for the solver specifying physical thickness of a cover glass. The cover glass is always assumed in image side of the lens. Default value is 0.";


(* ::Input::Initialization:: *)
mechanicalObjectImageDistance::usage="mechanicalObjectImageDistance is a parameter for the solver specifying mechanical O/I distance. If lateralMagnification = 0, imageObjectDistance is ignored. If both lateralMagnification and imageObjectDistance are specified, focalLength is ignored by the solver.";


(* ::Input::Initialization:: *)
objectSideCoverGlassMediumSymbol::usage="objectSideCoverGlassMediumSymbol s a parameter for the solver specifying cover glass material. It is treated same as lensMediumSymbol. If parameters are conditioned to infinite conjugate, this pareameter ignored.";


(* ::Input::Initialization:: *)
objectSideCoverGlassThickness::usage="objectSideCoverGlassThickness is a parameter for the solver specifying cover glass thickness in object space.";


(* ::Input::Initialization:: *)
marginRatio::usage="marginRatio is a parameter for the solver specifying numerical aperture margin.";


(* ::Input::Initialization:: *)
setDefaultMarginRatio::usage="setDefaultMarginRatio[mratio_] sets default marginRatio. mratio should be greater than 1.";


(* ::Input::Initialization:: *)
frontSurfaceShapeFunction::usage="frontSurfaceShapeFunction is a result tag of biasphericAplanatSolver. The rhs value is solved front surface (surface 1) shape function in the Mathematica InterpolatingFunction style.";


(* ::Input::Initialization:: *)
backSurfaceShapeFunction::usage="backSurfaceShapeFunction is a result tag of biasphericAplanatSolver. The rhs value is solved back surface (surface 2) shape function in the Mathematica InterpolatingFunction style.";


(* ::Input::Initialization:: *)
numericalAperture::usage="numericalAperture is a result tag of biasphericAplanatSolver. The rhs value is a numerical aperture value in the image space. If the solution for the parameter set is exist, numericalAperture value is equal to  numericalApertureTarget in the given parameter set.";


(* ::Input::Initialization:: *)
coverGlassExistence::usage="coverGlassExistence is a result tag of biasphericAplanatSolver and if True, input parameter set has a cover glass in the image space.";


(* ::Input::Initialization:: *)
objectSideCoverGlassExistence::usage="objectSideCoverGlassExistence is a result tag of biasphericAplanatSolver and if True, input parameter set has a cover glass in the object space. If conjugateInfiniteness is True, a coverGlassInObjectSpaceExistence rule expression is not included.";


(* ::Input::Initialization:: *)
paraxialParamters::usage="paraxialParamters is a result tag of biasphericAplanatSolver and contains paraxial parameters.";


(* ::Input::Initialization:: *)
inputParameters::usage="inputParameters is a result tag of biasphericAplanatSolver. The rhs is exactly the same as input parameter set.";


(* ::Input::Initialization:: *)
setOpticsFor2DRayTrace::usage="setOpticsFor2DRayTrace[op_Symbol,solverResult_:{__Rule},opt___Rule] build a optical object of RayTrace2D package. You can trace rays in the y-z plane to show the result graphically. You can refer the package description to know how to use the optical object.";


(* ::Input::Initialization:: *)
tracingWavelength::usage="tracingWavelength is an option of setOpticsFor2DRayTrace and specifies wavelength of ray to trace. Default value is 'designWavelength' in solverSesult.";


(* ::Input::Initialization:: *)
decenterBetweenAspherics::usage="decenterBetweenAspherics is an option of setOpticsFor2DRayTrace and specifies decenter length between two aspherical surfaces. Default value is 0.";


(* ::Input::Initialization:: *)
setupBiasphericAplanatParameters::usage="buildBiasphericAplanatParameters[__Rule] is a utlity function to build a consistent parameter set for solver. All parameters should be specified Rule style i.e., parameterName->value.";
biasphericAplanatParameterSymbols::usage="biasphericAplanatParameterSymbols contains parameter symbol set for the solver.";
paraxialOutlineGraphicsForParameters::usage="paraxialOutlineGraphicsForParameters[__Rule] draws a graphics of paraxial lens shape for checking.";
interactiveParameterSettingForBiasphericAplanat::usage="interactiveParameterSettingForBiasphericAplanat[opt___Rule] displays a notebook with dialog boxes for parameters.";


(* ::Input::Initialization:: *)
biasphericAplanatSolve::usage="biasphericAplanatSolve[parameters__Rule] performs numerical integration to fix shapes of two aspheric sufaces following given parameters and returns a list of InterpolatingFunctions of the shape and other characteristic values in a rule style. biasphericAplanatSolve can accept output of setupBiasphericAplanatParameters function as parameter arguments and Options of NDSolve built-in function.";


(* ::Input::Initialization:: *)
solverAsphericalSurface::usage="solverAsphericalSurface is a surface attribute of solver generated surface.";
frontSolverAsphericalSurface::usage="frontSolverAsphericalSurface is a attribute value for solverAsphericalSurface.";
backSolverAsphericalSurface::usage="backSolverAsphericalSurface is a attribute value for solverAsphericalSurface.";
frontAsphericalSurfacePosition::usage="frontAsphericalSurfacePosition[op_?opticsQ] returns front surface poisition in optics.";
backAsphericalSurfacePosition::usage="frontAsphericalSurfacePosition[op_?opticsQ] returns back surface poisition in optics.";


(* ::Input::Initialization:: *)
BiasphericAplanatSolverCoreFunctionUsage="Definitions of core functions of the solver bellow.
You can use the functions in your optimization loop.
All functions have fixed and ordered arguments.
If the arguments include inconsistency, the result is not guaranteed.

Five functions are now provided:
	- Infinite conjugate
		- no cover glass
		- with cover glass
	- Finite conjugate
		- no cover glass
		- with cover glass in image space
		- with cover glass in object space
		- with cover glasses in both image and object space

Function arguments:
	na:	numerical aperture target
	n:	refractive index value of lens medium
	d:	lens thickness
	m:	mechanical working distance (image space) for infinite conjugate case
	f:	focal length
	dc:	thickness of cover glass  for infinite conjugate case
	nc:	refractive index  of cover glass  for infinite conjugate case
	m1:	mechanical working distance in image space for finite conjugate case
	m2:	mechanical working distance in object space for finite conjugate case
	beta:	lateral magnification for finite conjugate case
	dc1:	thickness of cover glass  in image space for finite conjugate case
	nc1:	refractive index  of cover glass  in image space for finite conjugate case
	dc2:	thickness of cover glass  in object space for finite conjugate case
	nc2:	refractive index  of cover glass  in object space for finite conjugate case
You can find the order of the arguments in their usage messages.

Function returns a list with a style bellow:
	{_InterpolatingFunction, _InterpolatingFunction}
First element of the list is an interpolation function of front surface and second is of back.
The function domain is {0,h}
here, \[OpenCurlyQuote]h\[CloseCurlyQuote] is a maximum height of the surface."


(* ::Input::Initialization:: *)
BiasphericAplanatSolverCoreFunctions={SolveInfinite,SolveInfiniteWithCoverGlass,SolveFinite,SolveFiniteWithCoverGlass,SolveFiniteWithObjectSpaceCoverGlass,SolveFiniteWithBothSpaceCoverGlass};


(* ::Input::Initialization:: *)
SolveInfinite::usage="SolveInfinite[na_,n_,d_,m_,f_,opt___]";
SolveInfiniteWithCoverGlass::usage="SolveInfiniteWithCoverGlass[na_,n_,d_,m_,f_,dc_,nc_,opt___]";
SolveFinite::usage="SolveFinite[na_,n_,d_,m1_,m2_,beta_,opt___]";
SolveFiniteWithCoverGlass::usage="SolveFiniteWithCoverGlass[na_,n_,d_,m1_,m2_,beta_,dc_,nc_,opt___]";
SolveFiniteWithObjectSpaceCoverGlass::usage="SolveFiniteWithObjectSpaceCoverGlass[na_,n_,d_,m1_,m2_,beta_,dc_,nc_,opt___]";
SolveFiniteWithBothSpaceCoverGlass::usage="SolveFiniteWithBothSpaceCoverGlass[na_,n_,d_,m1_,m2_,beta_,dc1_,nc1_,dc2_,nc2_,opt___]";


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
biasphericAplanatParameterSymbols=Join[{designWavelength,lensMediumSymbol,numericalApertureTarget,mechanicalImageDistance,mechanicalObjectDistance,coverGlassExistence,coverGlassMediumSymbol,coverGlassThickness,mechanicalObjectImageDistance,objectSideCoverGlassExistence,objectSideCoverGlassMediumSymbol,objectSideCoverGlassThickness,marginRatio},singletParaxialParameterSymbols];


(* ::Input::Initialization:: *)
$marginRatio=1.02;


(* ::Input::Initialization:: *)
Clear[setDefaultMarginRatio];
setDefaultMarginRatio::notnumeric="argument `1` should be a numeric value.";
setDefaultMarginRatio::lessthan1="argument `1` should be greater than 1.";
setDefaultMarginRatio[mratio_]/;If[NumericQ[mratio],If[N[mratio]>1.,True,Message[setDefaultMarginRatio::lessthan1,mratio];False],Message[setDefaultMarginRatio::notnumeric,mratio];False]:=($marginRatio=mratio)


(* ::Input::Initialization:: *)
Clear[setupBiasphericAplanatParameters];
Options[setupBiasphericAplanatParameters]:={marginRatio->$marginRatio};
setupBiasphericAplanatParameters[parameters__Rule]:=setupBiasphericAplanatParameters[{parameters}]


(* ::Input::Initialization:: *)
setupBiasphericAplanatParameters[parameters:{__Rule}]:=Module[{wl,lm,n,icQ,ocQ,difid,difod,pwd,pod,poi,paramp,paraparm,conj,remp},
wl=designWavelength/.parameters;
If[! NumericQ[wl],Message[setupBiasphericAplanatParameters::needslambda];Return[$Fialed]];
lm=lensMediumSymbol/.parameters;
If[! mediumQ[lm],Message[setupBiasphericAplanatParameters::notmedium,lm,lensMediumSymbol];Return[$Failed]];
n=refractiveIndexValue[lm,wl];
icQ=hasImageSpaceCoverGlassPresentQ[parameters];
difid=If[icQ,Check[differenceToParaxialCoverGlass[wl,{coverGlassMediumSymbol,coverGlassThickness},parameters],Return[parameters]],0.0];
pwd=mechanicalImageDistance/.parameters;
ocQ=hasObjectSpaceCoverGlassPresentQ[parameters];
difod=If[ocQ,Check[differenceToParaxialCoverGlass[wl,{objectSideCoverGlassMediumSymbol,objectSideCoverGlassThickness},parameters],Return[parameters]],0.0];
pod=mechanicalObjectDistance/.parameters;
poi=mechanicalObjectImageDistance/.parameters;
paramp=Flatten[{parameters,lensMediumRefractiveIndex->n,If[NumericQ[pwd],paraxialWorkingDistance->pwd+difid,Nothing],If[NumericQ[pod],paraxialObjectDistance->pod+difod,Nothing],If[NumericQ[poi],paraxialObjectImageDistance->poi+difid+difod,Nothing]}];
paraparm=Check[settleRemainedParaxialParameters[paramp],Return[$Failed]];
remp={If[!NumericQ[pwd],mechanicalImageDistance->(paraxialWorkingDistance/.paraparm)-difid,Nothing],If[!(conjugateInfiniteness/.paraparm),{If[! NumericQ[pod],mechanicalObjectDistance->(paraxialObjectDistance/.paraparm)-difod,Nothing],If[! NumericQ[poi],mechanicalObjectImageDistance->(paraxialObjectImageDistance/.paraparm)-difid-difod,Nothing]},Nothing]};
Apply[Sequence,Flatten[{paramp,coverGlassExistence->icQ,If[conjugateInfiniteness/.paraparm,Nothing,objectSideCoverGlassExistence->ocQ],remp,paraparm,Options[setupBiasphericAplanatParameters]}]]
]


(* ::Input::Initialization:: *)
hasImageSpaceCoverGlassPresentQ[parameters__Rule]:=hasImageSpaceCoverGlassPresentQ[{parameters}]
hasImageSpaceCoverGlassPresentQ[parameters:{__Rule}]:=With[{plist=Map[First,parameters]},If[SubsetQ[plist,{coverGlassMediumSymbol,coverGlassThickness}],((coverGlassMediumSymbol/.parameters)=!=atmosphere)&&(N[(coverGlassThickness/.parameters)]>0.0),False]]


(* ::Input::Initialization:: *)
hasObjectSpaceCoverGlassPresentQ[parameters__Rule]:=hasObjectSpaceCoverGlassPresentQ[{parameters}]
hasObjectSpaceCoverGlassPresentQ[parameters:{__Rule}]:=With[{plist=Map[First,parameters]},If[SubsetQ[plist,{objectSideCoverGlassMediumSymbol,objectSideCoverGlassThickness}],((objectSideCoverGlassMediumSymbol/.parameters)=!=atmosphere)&&(N[(objectSideCoverGlassThickness/.parameters)]>0.0),False]]


(* ::Input::Initialization:: *)
differenceToParaxialCoverGlass[wavelength_,{cgms_,cgt_},parameters:{__Rule}]:=Module[{mc,nc,dc,wd},
mc=cgms/.parameters;
If[! mediumQ[mc],Message[setupBiasphericAplanatParameters::notmedium,mc,cgms];Return[$Failed]];
nc=refractiveIndexValue[mc,wavelength];
dc=cgt/.parameters;
paraxialThickessDifferenceFromMechanical[nc,dc]
]


(* ::Input::Initialization:: *)



(* ::Input::Initialization:: *)
Clear[biasphericAplanatSolve];
biasphericAplanatSolve[parameters__Rule]:=biasphericAplanatSolve[{parameters}]
biasphericAplanatSolve[parameters:{__Rule}]:=Module[{wl,ml,na,iconj,cgi,cgo},
iconj=conjugateInfiniteness/.parameters;
If[! TrueQ[Element[iconj,Booleans]],Message[biasphericAplanatSolve::usesetup];Return[parameters]];
wl=designWavelength/.parameters;
If[! NumericQ[wl],Message[biasphericAplanatSolve::usesetup];Return[parameters]];
ml=lensMediumSymbol/.parameters;
If[! mediumQ[ml],Message[biasphericAplanatSolve::usesetup];Return[parameters]];
na=numericalApertureTarget/.parameters;
If[! NumericQ[na],Message[biasphericAplanatSolve::usesetup];Return[parameters]];
cgi=coverGlassExistence/.parameters;
If[! iconj,cgo=objectSideCoverGlassExistence/.parameters];
branchSolver[iconj,cgi,cgo,parameters]
]


(* ::Input::Initialization:: *)
branchSolver[iconj_,cgi_,cgo_,parameters_]:=Switch[{iconj,cgi,cgo},
{True,False,_},biasphericAplanatSolveInfinite[parameters],
{True,True,_},biasphericAplanatSolveInfiniteWithCoverGlass[parameters],
{False,False,False},biasphericAplanatSolveFinite[parameters],
{False,True,False},biasphericAplanatSolveFiniteWithImageCoverGlass[parameters],
{False,False,True},biasphericAplanatSolveFiniteWithObjectCoverGlass[parameters],
{False,True,True},biasphericAplanatSolveFiniteWithBothImageAndObjectCoverGlass[parameters]]


(* ::Input::Initialization:: *)
commonParameters[parameters:{__Rule}]:={(*{mr,na,n,d,m}*)
marginRatio,
numericalApertureTarget,
refractiveIndexValue[lensMediumSymbol,designWavelength],
lensMediumThickness,mechanicalImageDistance}/.parameters


(* ::Input::Initialization:: *)
filterNDSolveOptions[parameters:{__Rule}]:=Apply[Sequence,FilterRules[parameters,Options[NDSolve]]]


(* ::Input::Initialization:: *)
biasphericAplanatSolveInfinite[parameters:{__Rule}]:=Module[{x1,x2,mr,na,n,d,m,f,shps,secpnts,ana},
{mr,na,n,d,m}=commonParameters[parameters];
f=focalLength/.parameters;
{x1,x2}=SolveInfinite[mr*na,n,d,m,f,filterNDSolveOptions[parameters]];
secpnts=interpolationSectionPoints[x1];
ana=Last[secpnts]/mr/.parameters;
Flatten[{frontSurfaceShapeFunction->Interpolation[mirroredData[Map[{f*#,x1[#]}&,secpnts]]],backSurfaceShapeFunction->Interpolation[mirroredData[Map[{# (m-x2[#])/Sqrt[1.0-#^2],x2[#]+d}&,secpnts]]],numericalAperture->ana,parameters}]
]


(* ::Input::Initialization:: *)
biasphericAplanatSolveInfiniteWithCoverGlass[parameters:{__Rule}]:=Module[{x1,x2,mr,na,n,d,m,f,dc,mc,nc,shps,secpnts,ana},
{mr,na,n,d,m}=commonParameters[parameters];
f=focalLength/.parameters;
dc=coverGlassThickness/.parameters;
mc=coverGlassMediumSymbol/.parameters;
nc=refractiveIndexValue[mc,designWavelength/.parameters];
{x1,x2}=SolveInfiniteWithCoverGlass[mr*na,n,d,m,f,dc,nc,filterNDSolveOptions[parameters]];
secpnts=interpolationSectionPoints[x1];
ana=Last[secpnts]/mr/.parameters;
Flatten[{frontSurfaceShapeFunction->Interpolation[mirroredData[Map[{f*#,x1[#]}&,secpnts]]],backSurfaceShapeFunction->Interpolation[mirroredData[Map[{#*(dc*(-(1/Sqrt[1-#^2])+1/Sqrt[-#^2+nc^2])+(m-x2[#])/Sqrt[1-#^2]),d+x2[#]}&,secpnts]]],numericalAperture->ana,parameters}]
]


(* ::Input::Initialization:: *)
biasphericAplanatSolveFinite[parameters:{__Rule}]:=Module[{x1,x2,mr,na,n,d,m1,m2,oi,beta,shps,secpnts,ana},
{mr,na,n,d,m2}=commonParameters[parameters];
oi=mechanicalObjectImageDistance/.parameters;
m1=If[NumericQ[oi],oi-m2-d,mechanicalObjectDistance/.parameters];
beta=-lateralMagnification/.parameters;(* why negate? see original expression *)
{x1,x2}=SolveFinite[mr*na*beta,n,d,m1,m2,beta,filterNDSolveOptions[parameters]];
secpnts=interpolationSectionPoints[x1];
ana=Last[secpnts]/mr/beta/.parameters;
Flatten[{frontSurfaceShapeFunction->Interpolation[mirroredData[Map[{(#*(m1+x1[#]))/Sqrt[1-#^2],x1[#]}&,secpnts]]],backSurfaceShapeFunction->Interpolation[mirroredData[Map[{(#*(m2-x2[#]))/Sqrt[-#^2+beta^2],d+x2[#]}&,secpnts]]],numericalAperture->ana,parameters}]
]


(* ::Input::Initialization:: *)
biasphericAplanatSolveFiniteWithImageCoverGlass[parameters:{__Rule}]:=Module[{x1,x2,mr,na,n,d,m1,m2,oi,beta,mc,dc,nc,shps,secpnts,ana},{mr,na,n,d,m2}=commonParameters[parameters];
oi=mechanicalObjectImageDistance/.parameters;
m1=If[NumericQ[oi],oi-m2-d,mechanicalObjectDistance/.parameters];
beta=-lateralMagnification/.parameters;
dc=coverGlassThickness/.parameters;
mc=coverGlassMediumSymbol/.parameters;
nc=refractiveIndexValue[mc,designWavelength/.parameters];
{x1,x2}=SolveFiniteWithCoverGlass[mr*na*beta,n,d,m1,m2,beta,dc,nc,filterNDSolveOptions[parameters]];
secpnts=interpolationSectionPoints[x1];
ana=Last[secpnts]/mr/beta/.parameters;
Flatten[{frontSurfaceShapeFunction->Interpolation[mirroredData[Map[{(#*(m1+x1[#]))/Sqrt[1-#^2],x1[#]}&,secpnts]]],backSurfaceShapeFunction->Interpolation[mirroredData[Map[{#*(dc*(-(1/Sqrt[-#^2+beta^2])+1/Sqrt[-#^2+beta^2*nc^2])+(m2-x2[#])/Sqrt[-#^2+beta^2]),d+x2[#]}&,secpnts]]],numericalAperture->ana,parameters}]
]


(* ::Input::Initialization:: *)
biasphericAplanatSolveFiniteWithObjectCoverGlass[parameters:{__Rule}]:=Module[{x1,x2,mr,na,n,d,m1,m2,oi,beta,mc,dc,nc,shps,secpnts,ana},
{mr,na,n,d,m2}=commonParameters[parameters];
oi=mechanicalObjectImageDistance/.parameters;
m1=If[NumericQ[oi],oi-m2-d,mechanicalObjectDistance/.parameters];
beta=-lateralMagnification/.parameters;
dc=objectSideCoverGlassThickness/.parameters;
mc=objectSideCoverGlassMediumSymbol/.parameters;
nc=refractiveIndexValue[mc,designWavelength/.parameters];
{x1,x2}=SolveFiniteWithObjectSpaceCoverGlass[mr*na*beta,n,d,m1,m2,beta,dc,nc,filterNDSolveOptions[parameters]];
secpnts=interpolationSectionPoints[x1];
ana=Last[secpnts]/mr/beta/.parameters;
Flatten[{frontSurfaceShapeFunction->Interpolation[mirroredData[Map[{#*((-(1/Sqrt[1-#^2])+1/Sqrt[nc^2-#^2])*dc+(m1+x1[#])/Sqrt[1-#^2]),x1[#]}&,secpnts]]],backSurfaceShapeFunction->Interpolation[mirroredData[Map[{(#*(m2-x2[#]))/Sqrt[beta^2-#^2],d+x2[#]}&,secpnts]]],numericalAperture->ana,parameters}]
]


(* ::Input::Initialization:: *)

biasphericAplanatSolveFiniteWithBothImageAndObjectCoverGlass[parameters:{__Rule}]:=Module[{x1,x2,mr,na,n,d,m1,m2,oi,beta,mc1,dc1,nc1,mc2,nc2,dc2,shps,secpnts,ana},
{mr,na,n,d,m2}=commonParameters[parameters];
oi=mechanicalObjectImageDistance/.parameters;
m1=If[NumericQ[oi],oi-m2-d,mechanicalObjectDistance/.parameters];
beta=-lateralMagnification/.parameters;
dc2=coverGlassThickness/.parameters;
mc2=coverGlassMediumSymbol/.parameters;
nc2=refractiveIndexValue[mc2,designWavelength/.parameters];
dc1=objectSideCoverGlassThickness/.parameters;
mc1=objectSideCoverGlassMediumSymbol/.parameters;
nc1=refractiveIndexValue[mc1,designWavelength/.parameters];
{x1,x2}=SolveFiniteWithBothSpaceCoverGlass[mr*na*beta,n,d,m1,m2,beta,dc1,nc1,dc2,nc2,filterNDSolveOptions[parameters]];
secpnts=interpolationSectionPoints[x1];
ana=Last[secpnts]/mr/beta/.parameters;
Flatten[{frontSurfaceShapeFunction->Interpolation[mirroredData[Map[{#*(dc1/(nc1*Sqrt[1-#^2/nc1^2])+(-dc1+m1)/Sqrt[1-#^2]+x1[#]/Sqrt[1-#^2]),x1[#]}&,secpnts]]],backSurfaceShapeFunction->Interpolation[mirroredData[Map[{#*(dc2/(beta*nc2*Sqrt[1-#^2/(beta^2*nc2^2)])+(-dc2+m2)/Sqrt[beta^2-#^2]-x2[#]/Sqrt[beta^2-#^2]),d+x2[#]}&,secpnts]]],numericalAperture->ana,parameters}]
]


(* ::Input::Initialization:: *)
SolveInfinite[na_,n_,d_,m_,f_,opt___]:=Module[{fn,x1,x2,t,sols},
fn=f*n;
sols=Flatten[NDSolve[{x1'[t]==-((fn*t*(-m+f*Sqrt[1-t^2]+x2[t]))/(Sqrt[1-t^2]*(-(d*n)+n*x1[t]-n*x2[t]+Sqrt[-((t^2*(-m+f*Sqrt[1-t^2]+x2[t])^2)/(-1+t^2))+(d-x1[t]+x2[t])^2]))),x2'[t]==(t*(m-x2[t])*(n(m-f*Sqrt[1-t^2]-x2[t])+Sqrt[1-t^2]*Sqrt[-((t^2*(-m+f*Sqrt[1-t^2]+x2[t])^2)/(-1+t^2))+(d-x1[t]+x2[t])^2]))/((-1+t^2)*(n*(d-d*t^2-m*t^2+f*t^2*Sqrt[1-t^2]+(-1+t^2)*x1[t]+x2[t])-Sqrt[1-t^2]*Sqrt[-((t^2*(-m+f*Sqrt[1-t^2]+x2[t])^2)/(-1+t^2))+(d-x1[t]+x2[t])^2])),x1[0]==0,x2[0]==0},{x1,x2},{t,0,na},opt]];
{x1/.sols,x2/.sols}
]


(* ::Input::Initialization:: *)
SolveInfiniteWithCoverGlass[na_,n_,d_,m_,f_,dc_,nc_,opt___]:=Module[{x1,x2,t,sols},
sols=Flatten[NDSolve[{x1'[t]==(f*n*t*(-f+(m-dc)/Sqrt[1-t^2]+dc/(Sqrt[1-t^2/nc^2]*nc)-x2[t]/Sqrt[1-t^2]))/(-(n*(d-x1[t]+x2[t]))+Sqrt[(d-x1[t]+x2[t])^2+t^2*(f+(-m+dc)/Sqrt[1-t^2]-dc/(Sqrt[1-t^2/nc^2]*nc)+x2[t]/Sqrt[1-t^2])^2]),x2'[t]==-((t*((m-dc)/(1-t^2)^(3/2)+(t^2*dc)/((1-t^2/nc^2)^(3/2)*nc^3)+dc/(Sqrt[1-t^2/nc^2]*nc)-x2[t]/(1-t^2)^(3/2))*(f*n+(n*(-m+dc))/Sqrt[1-t^2]-(n*dc)/(Sqrt[1-t^2/nc^2]*nc)+(n*x2[t])/Sqrt[1-t^2]-Sqrt[(d-x1[t]+x2[t])^2+t^2*(f+(-m+dc)/Sqrt[1-t^2]-dc/(Sqrt[1-t^2/nc^2]*nc)+x2[t]/Sqrt[1-t^2])^2]))/(-(n*(d-x1[t]+x2[t]))+(n*t^2*(-f+(m-dc)/Sqrt[1-t^2]+dc/(Sqrt[1-t^2/nc^2]*nc)-x2[t]/Sqrt[1-t^2]))/Sqrt[1-t^2]+Sqrt[(d-x1[t]+x2[t])^2+t^2*(f+(-m+dc)/Sqrt[1-t^2]-dc/(Sqrt[1-t^2/nc^2]*nc)+x2[t]/Sqrt[1-t^2])^2]/Sqrt[1-t^2])),x1[0]==0,x2[0]==0},{x1,x2},{t,0,na},opt]];
{x1/.sols,x2/.sols}
]


(* ::Input::Initialization:: *)
SolveFinite[na_,n_,d_,m1_,m2_,beta_,opt___]:=Module[{x1,x2,t,sols},
sols=Flatten[NDSolve[{x1'[t]==-(((m1+x1[t])*(-(n*(-((t*m1)/Sqrt[1-t^2])+(t*m2)/(Sqrt[1-t^2/beta^2]*beta)-(t*x1[t])/Sqrt[1-t^2]-(t*x2[t])/(Sqrt[1-t^2/beta^2]*beta)))+t*Sqrt[(d-x1[t]+x2[t])^2+((t*m1)/Sqrt[1-t^2]-(t*m2)/(Sqrt[1-t^2/beta^2]*beta)+(t*x1[t])/Sqrt[1-t^2]+(t*x2[t])/(Sqrt[1-t^2/beta^2]*beta))^2]))/((1-t^2)^(3/2)*(-(n*(d-x1[t]+x2[t]))-(n*t*(-((t*m1)/Sqrt[1-t^2])+(t*m2)/(Sqrt[1-t^2/beta^2]*beta)-(t*x1[t])/Sqrt[1-t^2]-(t*x2[t])/(Sqrt[1-t^2/beta^2]*beta)))/Sqrt[1-t^2]+Sqrt[(d-x1[t]+x2[t])^2+((t*m1)/Sqrt[1-t^2]-(t*m2)/(Sqrt[1-t^2/beta^2]*beta)+(t*x1[t])/Sqrt[1-t^2]+(t*x2[t])/(Sqrt[1-t^2/beta^2]*beta))^2]/Sqrt[1-t^2]))),x2'[t]==-((beta^2*(m2-x2[t])*(-(n*(-((t*m1)/Sqrt[1-t^2])+(t*m2)/(Sqrt[1-t^2/beta^2]*beta)-(t*x1[t])/Sqrt[1-t^2]-(t*x2[t])/(Sqrt[1-t^2/beta^2]*beta)))-(t*Sqrt[(d-x1[t]+x2[t])^2+((t*m1)/Sqrt[1-t^2]-(t*m2)/(Sqrt[1-t^2/beta^2]*beta)+(t*x1[t])/Sqrt[1-t^2]+(t*x2[t])/(Sqrt[1-t^2/beta^2]*beta))^2])/beta))/((-t^2+beta^2)^(3/2)*(-(n*(d-x1[t]+x2[t]))+(n*t^2*(Sqrt[1-t^2/beta^2]*beta*m1-Sqrt[1-t^2]*m2+Sqrt[1-t^2/beta^2]*beta*x1[t]+Sqrt[1-t^2]*x2[t]))/(Sqrt[1-t^2]*(t^2-beta^2))+Sqrt[(d-x1[t]+x2[t])^2+((t*m1)/Sqrt[1-t^2]-(t*m2)/(Sqrt[1-t^2/beta^2]*beta)+(t*x1[t])/Sqrt[1-t^2]+(t*x2[t])/(Sqrt[1-t^2/beta^2]*beta))^2]/Sqrt[1-t^2/beta^2]))),x1[0]==0,x2[0]==0},{x1,x2},{t,0,na},opt]];
{x1/.sols,x2/.sols}
]


(* ::Input::Initialization:: *)
SolveFiniteWithCoverGlass[na_,n_,d_,m1_,m2_,beta_,dc_,nc_,opt___]:=Module[{x1,x2,t,sols},
sols=Flatten[NDSolve[{x1'[t]==-(((m1+x1[t])*((n*t*m1)/Sqrt[1-t^2]+(n*t*(dc-m2))/(Sqrt[1-t^2/beta^2]*beta)-(n*t*dc)/(beta*Sqrt[1-t^2/(beta^2*nc^2)]*nc)+(n*t*x1[t])/Sqrt[1-t^2]+(n*t*x2[t])/(Sqrt[1-t^2/beta^2]*beta)+t*Sqrt[(d-x1[t]+x2[t])^2+((t*m1)/Sqrt[1-t^2]+(t*(dc-m2))/(Sqrt[1-t^2/beta^2]*beta)-(t*dc)/(beta*Sqrt[1-t^2/(beta^2*nc^2)]*nc)+(t*x1[t])/Sqrt[1-t^2]+(t*x2[t])/(Sqrt[1-t^2/beta^2]*beta))^2]))/((1-t^2)^(3/2)*(-(n*(d-x1[t]+x2[t]))-(n*t*(-((t*m1)/Sqrt[1-t^2])+(t*(-dc+m2))/(Sqrt[1-t^2/beta^2]*beta)+(t*dc)/(beta*Sqrt[1-t^2/(beta^2*nc^2)]*nc)-(t*x1[t])/Sqrt[1-t^2]-(t*x2[t])/(Sqrt[1-t^2/beta^2]*beta)))/Sqrt[1-t^2]+Sqrt[(d-x1[t]+x2[t])^2+((t*m1)/Sqrt[1-t^2]+(t*(dc-m2))/(Sqrt[1-t^2/beta^2]*beta)-(t*dc)/(beta*Sqrt[1-t^2/(beta^2*nc^2)]*nc)+(t*x1[t])/Sqrt[1-t^2]+(t*x2[t])/(Sqrt[1-t^2/beta^2]*beta))^2]/Sqrt[1-t^2]))),x2'[t]==-((beta^2*(m2-(dc*(t^4-2*t^2*beta^2*nc^2+Sqrt[1-t^2/beta^2]*beta^2*(t^2-beta^2)*Sqrt[1-t^2/(beta^2*nc^2)]*nc^3+beta^4*nc^4))/(t^2-beta^2*nc^2)^2-x2[t])*((n*t*m1)/Sqrt[1-t^2]+(n*t*(dc-m2))/(Sqrt[1-t^2/beta^2]*beta)-(n*t*dc)/(beta*Sqrt[1-t^2/(beta^2*nc^2)]*nc)+(n*t*x1[t])/Sqrt[1-t^2]+(n*t*x2[t])/(Sqrt[1-t^2/beta^2]*beta)-(t*Sqrt[(d-x1[t]+x2[t])^2+((t*m1)/Sqrt[1-t^2]+(t*(dc-m2))/(Sqrt[1-t^2/beta^2]*beta)-(t*dc)/(beta*Sqrt[1-t^2/(beta^2*nc^2)]*nc)+(t*x1[t])/Sqrt[1-t^2]+(t*x2[t])/(Sqrt[1-t^2/beta^2]*beta))^2])/beta))/((-t^2+beta^2)^(3/2)*(-(n*(d-x1[t]+x2[t]))+(n*t*(-((t*m1)/Sqrt[1-t^2])+(t*(-dc+m2))/(Sqrt[1-t^2/beta^2]*beta)+(t*dc)/(beta*Sqrt[1-t^2/(beta^2*nc^2)]*nc)-(t*x1[t])/Sqrt[1-t^2]-(t*x2[t])/(Sqrt[1-t^2/beta^2]*beta)))/(Sqrt[1-t^2/beta^2]*beta)+Sqrt[(d-x1[t]+x2[t])^2+((t*m1)/Sqrt[1-t^2]+(t*(dc-m2))/(Sqrt[1-t^2/beta^2]*beta)-(t*dc)/(beta*Sqrt[1-t^2/(beta^2*nc^2)]*nc)+(t*x1[t])/Sqrt[1-t^2]+(t*x2[t])/(Sqrt[1-t^2/beta^2]*beta))^2]/Sqrt[1-t^2/beta^2]))),x1[0]==0,x2[0]==0},{x1,x2},{t,0,na},opt]];
{x1/.sols,x2/.sols}
]


(* ::Input::Initialization:: *)
SolveFiniteWithObjectSpaceCoverGlass[na_,n_,d_,m1_,m2_,beta_,dc_,nc_,opt___]:=Module[{x1,x2,t,sols},
sols=Flatten[NDSolve[{x1'[t]==-((((-dc+m1)/(1-t^2)^(3/2)+(dc*t^2)/(nc^3*(1-t^2/nc^2)^(3/2))+dc/(nc*Sqrt[1-t^2/nc^2])+x1[t]/(1-t^2)^(3/2))*(((-dc+m1)*n*t)/Sqrt[1-t^2]-(m2*n*t)/(beta*Sqrt[1-t^2/beta^2])+(dc*n*t)/(nc*Sqrt[1-t^2/nc^2])+(n*t*x1[t])/Sqrt[1-t^2]+(n*t*x2[t])/(beta*Sqrt[1-t^2/beta^2])+t*Sqrt[(d-x1[t]+x2[t])^2+(((-dc+m1)*t)/Sqrt[1-t^2]-(m2*t)/(beta*Sqrt[1-t^2/beta^2])+(dc*t)/(nc*Sqrt[1-t^2/nc^2])+(t*x1[t])/Sqrt[1-t^2]+(t*x2[t])/(beta*Sqrt[1-t^2/beta^2]))^2]))/(-(n*(d-x1[t]+x2[t]))-(n*t*(((dc-m1)*t)/Sqrt[1-t^2]+(m2*t)/(beta*Sqrt[1-t^2/beta^2])-(dc*t)/(nc*Sqrt[1-t^2/nc^2])-(t*x1[t])/Sqrt[1-t^2]-(t*x2[t])/(beta*Sqrt[1-t^2/beta^2])))/Sqrt[1-t^2]+Sqrt[(d-x1[t]+x2[t])^2+(((-dc+m1)*t)/Sqrt[1-t^2]-(m2*t)/(beta*Sqrt[1-t^2/beta^2])+(dc*t)/(nc*Sqrt[1-t^2/nc^2])+(t*x1[t])/Sqrt[1-t^2]+(t*x2[t])/(beta*Sqrt[1-t^2/beta^2]))^2]/Sqrt[1-t^2])),x2'[t]==-((beta^2*(m2-x2[t])*(((-dc+m1)*n*t)/Sqrt[1-t^2]-(m2*n*t)/(beta*Sqrt[1-t^2/beta^2])+(dc*n*t)/(nc*Sqrt[1-t^2/nc^2])+(n*t*x1[t])/Sqrt[1-t^2]+(n*t*x2[t])/(beta*Sqrt[1-t^2/beta^2])-(t*Sqrt[(d-x1[t]+x2[t])^2+(((-dc+m1)*t)/Sqrt[1-t^2]-(m2*t)/(beta*Sqrt[1-t^2/beta^2])+(dc*t)/(nc*Sqrt[1-t^2/nc^2])+(t*x1[t])/Sqrt[1-t^2]+(t*x2[t])/(beta*Sqrt[1-t^2/beta^2]))^2])/beta))/((beta^2-t^2)^(3/2)*(-(n*(d-x1[t]+x2[t]))+(n*t*(((dc-m1)*t)/Sqrt[1-t^2]+(m2*t)/(beta*Sqrt[1-t^2/beta^2])-(dc*t)/(nc*Sqrt[1-t^2/nc^2])-(t*x1[t])/Sqrt[1-t^2]-(t*x2[t])/(beta*Sqrt[1-t^2/beta^2])))/(beta*Sqrt[1-t^2/beta^2])+Sqrt[(d-x1[t]+x2[t])^2+(((-dc+m1)*t)/Sqrt[1-t^2]-(m2*t)/(beta*Sqrt[1-t^2/beta^2])+(dc*t)/(nc*Sqrt[1-t^2/nc^2])+(t*x1[t])/Sqrt[1-t^2]+(t*x2[t])/(beta*Sqrt[1-t^2/beta^2]))^2]/Sqrt[1-t^2/beta^2]))),x1[0]==0,x2[0]==0},{x1,x2},{t,0,na},opt]];
{x1/.sols,x2/.sols}
]


(* ::Input::Initialization:: *)
SolveFiniteWithBothSpaceCoverGlass[na_,n_,d_,m1_,m2_,beta_,dc1_,nc1_,dc2_,nc2_,opt___]:=Module[{x1,x2,t,sols},
sols=Flatten[NDSolve[{x1'[t]==-((((-dc1+m1)/(1-t^2)^(3/2)+(t^2*dc1)/((1-t^2/nc1^2)^(3/2)*nc1^3)+dc1/(Sqrt[1-t^2/nc1^2]*nc1)+x1[t]/(1-t^2)^(3/2))*((n*t*(-dc1+m1))/Sqrt[1-t^2]+(n*t*(dc2-m2))/(Sqrt[1-t^2/beta^2]*beta)+(n*t*dc1)/(Sqrt[1-t^2/nc1^2]*nc1)-(n*t*dc2)/(beta*Sqrt[1-t^2/(beta^2*nc2^2)]*nc2)+(n*t*x1[t])/Sqrt[1-t^2]+(n*t*x2[t])/(Sqrt[1-t^2/beta^2]*beta)+t*Sqrt[(d-x1[t]+x2[t])^2+((t*(dc1-m1))/Sqrt[1-t^2]+(t*(-dc2+m2))/(Sqrt[1-t^2/beta^2]*beta)-(t*dc1)/(Sqrt[1-t^2/nc1^2]*nc1)+(t*dc2)/(beta*Sqrt[1-t^2/(beta^2*nc2^2)]*nc2)-(t*x1[t])/Sqrt[1-t^2]-(t*x2[t])/(Sqrt[1-t^2/beta^2]*beta))^2]))/(-(n*(d-x1[t]+x2[t]))-(n*t*((t*(dc1-m1))/Sqrt[1-t^2]+(t*(-dc2+m2))/(Sqrt[1-t^2/beta^2]*beta)-(t*dc1)/(Sqrt[1-t^2/nc1^2]*nc1)+(t*dc2)/(beta*Sqrt[1-t^2/(beta^2*nc2^2)]*nc2)-(t*x1[t])/Sqrt[1-t^2]-(t*x2[t])/(Sqrt[1-t^2/beta^2]*beta)))/Sqrt[1-t^2]+Sqrt[(d-x1[t]+x2[t])^2+((t*(dc1-m1))/Sqrt[1-t^2]+(t*(-dc2+m2))/(Sqrt[1-t^2/beta^2]*beta)-(t*dc1)/(Sqrt[1-t^2/nc1^2]*nc1)+(t*dc2)/(beta*Sqrt[1-t^2/(beta^2*nc2^2)]*nc2)-(t*x1[t])/Sqrt[1-t^2]-(t*x2[t])/(Sqrt[1-t^2/beta^2]*beta))^2]/Sqrt[1-t^2])),x2'[t]==-((beta^2*(m2-(dc2*(t^4-2*t^2*beta^2*nc2^2+Sqrt[1-t^2/beta^2]*beta^2*(t^2-beta^2)*Sqrt[1-t^2/(beta^2*nc2^2)]*nc2^3+beta^4*nc2^4))/(t^2-beta^2*nc2^2)^2-x2[t])*((n*t*(-dc1+m1))/Sqrt[1-t^2]+(n*t*(dc2-m2))/(Sqrt[1-t^2/beta^2]*beta)+(n*t*dc1)/(Sqrt[1-t^2/nc1^2]*nc1)-(n*t*dc2)/(beta*Sqrt[1-t^2/(beta^2*nc2^2)]*nc2)+(n*t*x1[t])/Sqrt[1-t^2]+(n*t*x2[t])/(Sqrt[1-t^2/beta^2]*beta)-(t*Sqrt[(d-x1[t]+x2[t])^2+((t*(dc1-m1))/Sqrt[1-t^2]+(t*(-dc2+m2))/(Sqrt[1-t^2/beta^2]*beta)-(t*dc1)/(Sqrt[1-t^2/nc1^2]*nc1)+(t*dc2)/(beta*Sqrt[1-t^2/(beta^2*nc2^2)]*nc2)-(t*x1[t])/Sqrt[1-t^2]-(t*x2[t])/(Sqrt[1-t^2/beta^2]*beta))^2])/beta))/((-t^2+beta^2)^(3/2)*(-(n*(d-x1[t]+x2[t]))+(n*t*((t*(dc1-m1))/Sqrt[1-t^2]+(t*(-dc2+m2))/(Sqrt[1-t^2/beta^2]*beta)-(t*dc1)/(Sqrt[1-t^2/nc1^2]*nc1)+(t*dc2)/(beta*Sqrt[1-t^2/(beta^2*nc2^2)]*nc2)-(t*x1[t])/Sqrt[1-t^2]-(t*x2[t])/(Sqrt[1-t^2/beta^2]*beta)))/(Sqrt[1-t^2/beta^2]*beta)+Sqrt[(d-x1[t]+x2[t])^2+((t*(dc1-m1))/Sqrt[1-t^2]+(t*(-dc2+m2))/(Sqrt[1-t^2/beta^2]*beta)-(t*dc1)/(Sqrt[1-t^2/nc1^2]*nc1)+(t*dc2)/(beta*Sqrt[1-t^2/(beta^2*nc2^2)]*nc2)-(t*x1[t])/Sqrt[1-t^2]-(t*x2[t])/(Sqrt[1-t^2/beta^2]*beta))^2]/Sqrt[1-t^2/beta^2]))),x1[0]==0,x2[0]==0},{x1,x2},{t,0,na},opt]];
{x1/.sols,x2/.sols}
]


(* ::Input::Initialization:: *)
mirroredData[l:{{_,_}...}]:=Union[Join[Map[{-#[[1]],#[[2]]}&,l],l],SameTest->(Abs[#1[[1]]-#2[[1]]]<10^-10&)]


(* ::Input::Initialization:: *)
Options[setOpticsFor2DRayTrace]={tracingWavelength->designWavelength,decenterBetweenAspherics->0};


(* ::Input::Initialization:: *)
setOpticsFor2DRayTrace[op_Symbol,solverResult:{__Rule},opt___Rule]:=If[conjugateInfiniteness/.solverResult,setOpticsFor2DRayTraceInfinite[op,solverResult,opt],
setOpticsFor2DRayTraceFinite[op,solverResult,opt]
]


(* ::Input::Initialization:: *)
setOpticsFor2DRayTraceInfinite[op_Symbol,solverResult:{__Rule},opt___Rule]:=Module[{wl,s1,pup,s2,img,ref,cgi,cgo,bod,ncg,dec,mrg},
wl=tracingWavelength/.{opt}/.{tracingWavelength->(designWavelength/.solverResult)};
dec=decenterBetweenAspherics/.{opt}/.Options[setOpticsFor2DRayTrace];
createSurface[s1,parametricShape[frontSurfaceShapeFunction/.solverResult],{0,0}];
attachAttributeToSurface[s1,solverAsphericalSurface,frontSolverAsphericalSurface];
createSurface[pup,planeShape[],{0,marginalPositionOfSurface[s1][[-1,1]]}];
createSurface[s2,parametricShape[backSurfaceShapeFunction/.solverResult],{dec,0}];
attachAttributeToSurface[s2,solverAsphericalSurface,backSolverAsphericalSurface];
createSurface[img,planeShape[{-2,2}],{0,lensMediumThickness+mechanicalImageDistance/.solverResult}];
createSurface[ref,sphericalShape[1/focalLength/.solverResult],{0,lensMediumThickness+mechanicalImageDistance-focalLength/.solverResult}];
bod=lensMediumSymbol/.solverResult;
Clear[op];
If[coverGlassExistence/.solverResult,createSurface[cgi,planeShape[],{0,(lensMediumThickness+mechanicalImageDistance/2-coverGlassThickness/2)/.solverResult}];
createSurface[cgo,planeShape[],{0,(lensMediumThickness+mechanicalImageDistance/2+coverGlassThickness/2)/.solverResult}];
ncg=coverGlassMediumSymbol/.solverResult;
createOptics[op,{atmosphere,s1,bod,pup,bod,s2,atmosphere,cgi,ncg,cgo,atmosphere,img,atmosphere,ref,atmosphere}],
createOptics[op,{atmosphere,s1,bod,pup,bod,s2,atmosphere,img,atmosphere,ref,atmosphere}]];
mrg=numericalAperture*focalLength/.solverResult;
traceRay[op][markRayAsDomainDefinedMarginal[raySet[{mrg,-0.3},{0,1}]],wl];
setPupil[op,pup];
op
]


(* ::Input::Initialization:: *)
setOpticsFor2DRayTraceFinite[op_Symbol,solverResult:{__Rule},opt___Rule]:=Module[{wl,s1,pup,s2,img,ref,cg1i,cg1o,cg2i,cg2o,bod,ncg1,ncg2,do,oplis,dec,mrg},
wl=tracingWavelength/.{opt}/.{tracingWavelength->(designWavelength/.solverResult)};
dec=decenterBetweenAspherics/.{opt}/.Options[setOpticsFor2DRayTrace];
oplis=If[objectSideCoverGlassExistence/.solverResult,
createSurface[cg1i,planeShape[],{0,(-mechanicalObjectDistance/2-objectSideCoverGlassThickness/2)/.solverResult}];
createSurface[cg1o,planeShape[],{0,(-mechanicalObjectDistance/2+objectSideCoverGlassThickness/2)/.solverResult}];
ncg1=objectSideCoverGlassMediumSymbol/.solverResult;
{atmosphere,cg1i,ncg1,cg1o,atmosphere},{atmosphere}];
createSurface[s1,parametricShape[frontSurfaceShapeFunction/.solverResult],{0,0}];
attachAttributeToSurface[s1,solverAsphericalSurface,frontSolverAsphericalSurface];
createSurface[pup,planeShape[],{0,marginalPositionOfSurface[s1][[-1,1]]}];
createSurface[s2,parametricShape[backSurfaceShapeFunction/.solverResult],{dec,0}];
attachAttributeToSurface[s2,solverAsphericalSurface,backSolverAsphericalSurface];
createSurface[img,planeShape[{-2,2}],{0,lensMediumThickness+mechanicalImageDistance/.solverResult}];
createSurface[ref,sphericalShape[1/focalLength/.solverResult],{0,lensMediumThickness+mechanicalImageDistance-focalLength/.solverResult}];
bod=lensMediumSymbol/.solverResult;
oplis=Flatten[{oplis,s1,bod,pup,bod,s2,atmosphere}];
If[coverGlassExistence/.solverResult,createSurface[cg2i,planeShape[],{0,(lensMediumThickness+mechanicalImageDistance/2-coverGlassThickness/2)/.solverResult}];
createSurface[cg2o,planeShape[],{0,(lensMediumThickness+mechanicalImageDistance/2+coverGlassThickness/2)/.solverResult}];
ncg2=coverGlassMediumSymbol/.solverResult;
oplis=Flatten[{oplis,cg2i,ncg2,cg2o,atmosphere}];
];
createSurface[img,planeShape[{-2,2}],{0,lensMediumThickness+mechanicalImageDistance/.solverResult}];oplis=Flatten[{oplis,img,atmosphere,ref,atmosphere}];
Clear[op];
createOptics[op,oplis];
mrg=ArcSin[-numericalAperture*lateralMagnification/.solverResult];
do=mechanicalObjectDistance/.solverResult;
traceRay[op][markRayAsDomainDefinedMarginal[raySet[{0,-do},{Sin[mrg],Cos[mrg]}]],wl];
setPupil[op,pup];
op
]
frontAsphericalSurfacePosition[op_?opticsQ]:=positionOfAttributedSurface[op,solverAsphericalSurface,frontSolverAsphericalSurface];
backAsphericalSurfacePosition[op_?opticsQ]:=positionOfAttributedSurface[op,solverAsphericalSurface,backSolverAsphericalSurface];


(* ::Input::Initialization:: *)
biasphericAplanatSolve::usesetup="use 'setupBiasphericAplanatParameters' function to set parameter arguments.";
setupBiasphericAplanatParameters::needslambda="design wavelength should be specified by 'designWavelength->x' with unit in milli meters.";
setupBiasphericAplanatParameters::notmedium="`1` symbol for `2` is not a medium symbol.";


(* ::Input::Initialization:: *)
End[];
EndPackage[];



